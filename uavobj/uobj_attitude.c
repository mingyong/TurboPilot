/**
 ******************************************************************************
 * @file       ubj_attitude.c
 * @author     王乐辉<wanglehui8357@163.com> Copyright (C) 2013.
 * @brief      Implementation of the Attitude Export Data Type. This file has been
 *             automatically generated by the GearCoder.
 *             $(DESCRIPTION)
 * @note       This is an automatically generated file.
 *             !!!DO NOT modify manually!!!.
 ******************************************************************************
**/

#include "uobj_attitude.h"
#include "uobjadmin.h"
#include "syncobj.h"

/******************************************************************************/
/* Global Variable*/
static UObj_Attitude gAttitudeInst;
static UObjMetaData gAttitudeMetaData;

/*
 * 辅助函数，获取指定成员变量的内存占用大小
*/
static TP_STATUS _Attitude_MemberSize(U32 memID)
{
    if(memID > UOBJ_ATTITUDE_MEMBERCNT)
    {
        return TP_INVALID_MEMBERID;
    }

	switch(memID)
	{
	case 0: return sizeof(UObj_Attitude);
    case 1: return sizeof(FP32);
	case 2: return sizeof(FP32);
	case 3: return sizeof(FP32);
	case 4: return sizeof(FP32);
	case 5: return sizeof(FP32);
	case 6: return sizeof(FP32);
	case 7: return sizeof(FP32);
	case 8: return sizeof(FP32);
	
    default:
        return TP_INVALID_MEMBERID;
	}
	return TP_OK;
}


/*
 * 辅助函数，设置指定成员变量内容
*/
static TP_STATUS _Attitude_SetValue(U32 instId, U32 memID, void* newVal)
{
    TP_STATUS status;

    _UOBJ_SYNC_t obj;
    CreateSyncObj(&obj);
    if(memID > UOBJ_ATTITUDE_MEMBERCNT)
    {
        return TP_INVALID_MEMBERID;
    }

    if(instId >= UOBJ_ATTITUDE_INSTCNT)
    {
        return TP_INVALID_INSTID;
    }

    RequestGrant(obj);
    switch(memID)
    {
    case 1: memcpy(valPtr, &gAttitudeInst.CurRoll, sizeof(FP32));
	case 2: memcpy(valPtr, &gAttitudeInst.CurPitch, sizeof(FP32));
	case 3: memcpy(valPtr, &gAttitudeInst.CurYaw, sizeof(FP32));
	case 4: memcpy(valPtr, &gAttitudeInst.CurHeading, sizeof(FP32));
	case 5: memcpy(valPtr, &gAttitudeInst.HeadingDot, sizeof(FP32));
	case 6: memcpy(valPtr, &gAttitudeInst.CurRollDot, sizeof(FP32));
	case 7: memcpy(valPtr, &gAttitudeInst.CurPitchDot, sizeof(FP32));
	case 8: memcpy(valPtr, &gAttitudeInst.CurYawDot, sizeof(FP32));
	
    }
    ReleaseGrant(obj);
    return TP_OK;
}

/*
 * 辅助函数，获取指定成员变量内容
*/
static TP_STATUS _Attitude_GetValue(U32 instId, U32 memID, void* valBuf, U32 bufSize)
{
    _UOBJ_SYNC_t obj;
    CreateSyncObj(&obj);

    if(memID > UObj_ATTITUDE_MEMBERCNT)
    {
        return TP_INVALID_MEMBERID;
    }

    if(instId >= UObj_ATTITUDE_INSTCNT)
    {
        return TP_INVALID_INSTID;
    }

    RequestGrant(obj);
    switch(memID)
    {
    case 1: memcpy(&gAttitudeInst.CurRoll, valPtr, sizeof(FP32));
	case 2: memcpy(&gAttitudeInst.CurPitch, valPtr, sizeof(FP32));
	case 3: memcpy(&gAttitudeInst.CurYaw, valPtr, sizeof(FP32));
	case 4: memcpy(&gAttitudeInst.CurHeading, valPtr, sizeof(FP32));
	case 5: memcpy(&gAttitudeInst.HeadingDot, valPtr, sizeof(FP32));
	case 6: memcpy(&gAttitudeInst.CurRollDot, valPtr, sizeof(FP32));
	case 7: memcpy(&gAttitudeInst.CurPitchDot, valPtr, sizeof(FP32));
	case 8: memcpy(&gAttitudeInst.CurYawDot, valPtr, sizeof(FP32));
	
    }
    ReleaseGrant(obj);

    return TP_OK;
}

void Attitude_Init(void)
{
    gAttitudeMetaData.memberCnt = UObj_ATTITUDE_MEMBERCNT;
    gAttitudeMetaData.accessType =  $(ACCESS_TYPE);
    gAttitudeMetaData.pFunMemberSize = _Attitude_MemberSize;
    gAttitudeMetaData.pFunGetValue = _Attitude_GetValue;
    gAttitudeMetaData.pFunSetValue = _Attitude_SetValue;

    gMetaDataTab[UObj_ATTITUDE_ID] = &gAttitudeMetaData;
}

TP_STATUS Attitude_Get_CurRoll(FP32 *valPtr)
{
	return _Attitude_GetValue(0, 0, valPtr, sizeof(FP32));
}
TP_STATUS Attitude_Get_CurPitch(FP32 *valPtr)
{
	return _Attitude_GetValue(0, 1, valPtr, sizeof(FP32));
}
TP_STATUS Attitude_Get_CurYaw(FP32 *valPtr)
{
	return _Attitude_GetValue(0, 2, valPtr, sizeof(FP32));
}
TP_STATUS Attitude_Get_CurHeading(FP32 *valPtr)
{
	return _Attitude_GetValue(0, 3, valPtr, sizeof(FP32));
}
TP_STATUS Attitude_Get_HeadingDot(FP32 *valPtr)
{
	return _Attitude_GetValue(0, 4, valPtr, sizeof(FP32));
}
TP_STATUS Attitude_Get_CurRollDot(FP32 *valPtr)
{
	return _Attitude_GetValue(0, 5, valPtr, sizeof(FP32));
}
TP_STATUS Attitude_Get_CurPitchDot(FP32 *valPtr)
{
	return _Attitude_GetValue(0, 6, valPtr, sizeof(FP32));
}
TP_STATUS Attitude_Get_CurYawDot(FP32 *valPtr)
{
	return _Attitude_GetValue(0, 7, valPtr, sizeof(FP32));
}

TP_STATUS Attitude_Set_CurRoll(FP32 *valPtr)
{
	return _Attitude_SetValue(0, 0, valPtr, sizeof(FP32);
}
TP_STATUS Attitude_Set_CurPitch(FP32 *valPtr)
{
	return _Attitude_SetValue(0, 1, valPtr, sizeof(FP32);
}
TP_STATUS Attitude_Set_CurYaw(FP32 *valPtr)
{
	return _Attitude_SetValue(0, 2, valPtr, sizeof(FP32);
}
TP_STATUS Attitude_Set_CurHeading(FP32 *valPtr)
{
	return _Attitude_SetValue(0, 3, valPtr, sizeof(FP32);
}
TP_STATUS Attitude_Set_HeadingDot(FP32 *valPtr)
{
	return _Attitude_SetValue(0, 4, valPtr, sizeof(FP32);
}
TP_STATUS Attitude_Set_CurRollDot(FP32 *valPtr)
{
	return _Attitude_SetValue(0, 5, valPtr, sizeof(FP32);
}
TP_STATUS Attitude_Set_CurPitchDot(FP32 *valPtr)
{
	return _Attitude_SetValue(0, 6, valPtr, sizeof(FP32);
}
TP_STATUS Attitude_Set_CurYawDot(FP32 *valPtr)
{
	return _Attitude_SetValue(0, 7, valPtr, sizeof(FP32);
}


/**********************************************************************/
TP_STATUS Attitude_Get( UObj_Attitude *valPtr)
{
    _UOBJ_SYNC_t obj;
    CreateSyncObj(&obj);
    if(instId >= UObj_ATTITUDE_INSTCNT)
    {
        return TP_INVALID_INSTID;
    }

    RequestGrant(obj);
    memcpy(valuePtr, &gAttitudeInst, sizeof(UObj_Attitude));
    ReleaseGrant(obj);

    return TP_OK;
}
/**********************************************************************/
TP_STATUS Attitude_Set( UObj_Attitude *valPtr)
{
    _UOBJ_SYNC_t obj;
    CreateSyncObj(&obj);
    if(instId >= UObj_ATTITUDE_INSTCNT)
    {
        return TP_INVALID_INSTID;
    }

    RequestGrant(obj);
    memcpy(&gAttitudeInst, valuePtr, sizeof(UObj_Attitude));
    ReleaseGrant(obj);

    return TP_OK;
}
